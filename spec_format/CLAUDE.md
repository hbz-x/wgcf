# OpenAPI Specification Formatting

This directory contains a specialized tool for post-processing and formatting OpenAPI specifications generated by Optic. The formatter ensures generated specs meet quality standards, follow conventions, and integrate properly with the documentation generation pipeline.

## Overview

The `spec_format/` directory implements the specification formatting stage of the API documentation workflow:

1. **Post-Processing**: Clean and enhance raw OpenAPI specs from Optic
2. **Standardization**: Apply consistent formatting and naming conventions
3. **Validation**: Ensure specs comply with OpenAPI 3.0 standards
4. **Optimization**: Improve spec structure for better client code generation

## Architecture

### Core Components

**`main.go`** - Simple, focused formatter that:
- Processes the generated OpenAPI specification file
- Applies standardization and cleanup rules through the `optic-go` library
- Outputs a properly formatted specification ready for client generation
- Integrates seamlessly with the broader documentation pipeline

### Key Dependencies

- **`github.com/ViRb3/optic-go`** - Provides the `Format()` function for spec processing
- **Standard Library**: Minimal dependencies for maximum reliability and performance

## Formatting Process

### 1. Input Processing

```go
const SpecFile = "openapi-spec.json"

func main() {
    if err := opticgo.Format(SpecFile); err != nil {
        log.Fatalln(err)
    }
}
```

**Input Requirements:**
- **File Location**: Expects `openapi-spec.json` in the project root
- **Format**: Valid OpenAPI 3.0 JSON specification
- **Source**: Generated by Optic from `api_tests/` execution
- **Size**: Handles specifications of any reasonable size

### 2. Formatting Operations

The `opticgo.Format()` function performs several critical transformations:

**Schema Standardization:**
- Normalizes property names and types
- Ensures consistent schema structure
- Resolves circular references and dependencies
- Validates schema compliance with OpenAPI 3.0

**Response Model Cleanup:**
- Standardizes response object naming conventions
- Removes redundant or duplicate schemas
- Optimizes nested object structures
- Ensures proper inheritance and composition

**Request/Response Validation:**
- Validates all endpoint definitions
- Ensures proper parameter definitions
- Checks required vs optional field specifications
- Verifies authentication requirements

**Documentation Enhancement:**
- Adds missing descriptions where possible
- Standardizes parameter documentation
- Ensures consistent operation summaries
- Optimizes for code generator compatibility

### 3. Output Generation

The formatter outputs a cleaned specification that:
- Maintains the original `openapi-spec.json` filename
- Preserves all functional API definitions
- Improves structure for downstream processing
- Ensures compatibility with OpenAPI Generator

## Integration with Generation Pipeline

### Pipeline Position

The spec formatter occupies a critical position in the documentation generation workflow:

```bash
# generate-api.sh workflow:

# 1. API tests generate raw specification
api generate:oas --json
mv ".optic/generated/openapi.json" "openapi-spec.json"

# 2. Spec formatting (THIS STAGE)
go run "spec_format/main.go"

# 3. Client code generation
openapi-generator-cli generate -i "openapi-spec.json" -g go -o "openapi"
```

### Before Formatting

**Raw Optic Output Characteristics:**
- May contain inconsistent naming conventions
- Potentially includes redundant schema definitions
- Could have suboptimal property orderings
- Might lack proper validation constraints

**Example Raw Output Issues:**
```json
{
  "components": {
    "schemas": {
      "GetAccount200Response": {
        "properties": {
          "account_type": {"type": "string"},
          "id": {"type": "string"},
          "created": {"type": "string"}  // Missing format specification
        }
      }
    }
  }
}
```

### After Formatting

**Formatted Specification Benefits:**
- Consistent schema naming and structure
- Proper type definitions and constraints
- Optimized for client code generation
- Enhanced documentation and examples

**Example Formatted Output:**
```json
{
  "components": {
    "schemas": {
      "GetAccount200Response": {
        "type": "object",
        "required": ["account_type", "id", "created"],
        "properties": {
          "account_type": {
            "type": "string",
            "description": "Account type classification"
          },
          "id": {
            "type": "string",
            "description": "Unique account identifier"
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "description": "Account creation timestamp"
          }
        }
      }
    }
  }
}
```

## Formatting Rules and Standards

### 1. Naming Conventions

**Schema Names:**
- PascalCase for schema objects (e.g., `GetAccount200Response`)
- Consistent endpoint-based naming patterns
- Clear distinction between request/response models
- Hierarchical naming for nested objects

**Property Names:**
- snake_case for JSON properties (matching API responses)
- Consistent abbreviation standards
- Descriptive names avoiding ambiguity
- Reserved word handling for language compatibility

### 2. Type System Enhancements

**String Types:**
- Format specifications for dates, UUIDs, emails
- Pattern constraints for structured strings
- Enum definitions for limited value sets
- Length constraints where applicable

**Numeric Types:**
- Appropriate type selection (integer vs number)
- Range constraints (minimum/maximum values)
- Format specifications (int32, int64, float, double)
- Unit documentation in descriptions

**Object Types:**
- Required vs optional property specifications
- Nested object handling and flattening
- Composition over inheritance where appropriate
- Circular reference resolution

### 3. Documentation Standards

**Descriptions:**
- Clear, concise property descriptions
- Endpoint operation summaries
- Parameter usage explanations
- Example value specifications

**Examples:**
- Representative data examples
- Edge case demonstrations
- Common usage patterns
- Authentication examples

## Customization and Extension

### Modifying Formatting Logic

To customize the formatting behavior:

1. **Extend the Format Function**: The `opticgo.Format()` function can be enhanced with additional parameters or custom logic
2. **Pre-Processing**: Add custom logic before calling `Format()` to handle specific requirements
3. **Post-Processing**: Add additional formatting steps after the core formatting
4. **Configuration**: Implement configuration files for formatting options

**Example Custom Enhancement:**
```go
package main

import (
    opticgo "github.com/ViRb3/optic-go"
    "encoding/json"
    "io/ioutil"
    "log"
)

const SpecFile = "openapi-spec.json"

func main() {
    // Pre-processing: custom validation
    if err := validateSpecFile(SpecFile); err != nil {
        log.Fatalln("Pre-validation failed:", err)
    }
    
    // Core formatting
    if err := opticgo.Format(SpecFile); err != nil {
        log.Fatalln("Formatting failed:", err)
    }
    
    // Post-processing: custom enhancements
    if err := addCustomDocumentation(SpecFile); err != nil {
        log.Fatalln("Post-processing failed:", err)
    }
}

func validateSpecFile(filename string) error {
    // Custom validation logic
    return nil
}

func addCustomDocumentation(filename string) error {
    // Custom documentation enhancement
    return nil
}
```

### Configuration Options

**Environment Variables:**
- `SPEC_FORMAT_DEBUG`: Enable verbose formatting logs
- `SPEC_FORMAT_OUTPUT`: Specify custom output file location
- `SPEC_FORMAT_RULES`: Path to custom formatting rules file

**Formatting Rules File:**
```json
{
  "naming": {
    "schema_case": "PascalCase",
    "property_case": "snake_case"
  },
  "validation": {
    "require_descriptions": true,
    "require_examples": false,
    "strict_types": true
  },
  "enhancement": {
    "add_missing_required": true,
    "optimize_schemas": true,
    "resolve_references": true
  }
}
```

## Quality Assurance

### Validation Checks

The formatter implements several validation checks:

1. **Schema Validity**: Ensures all schemas are valid OpenAPI 3.0 objects
2. **Reference Integrity**: Verifies all `$ref` references resolve correctly
3. **Type Consistency**: Validates property types match usage patterns
4. **Required Fields**: Ensures required properties are properly specified
5. **Constraint Logic**: Validates that constraints are logically consistent

### Error Handling

**Common Formatting Errors:**
- **Invalid JSON**: Malformed input specification
- **Schema Conflicts**: Conflicting type definitions
- **Missing References**: Unresolvable `$ref` references
- **Circular Dependencies**: Self-referencing schema loops
- **Invalid Constraints**: Contradictory validation rules

**Error Recovery:**
```go
func main() {
    if err := opticgo.Format(SpecFile); err != nil {
        log.Printf("Formatting failed: %v", err)
        
        // Attempt basic validation to identify specific issues
        if validationErr := basicValidation(SpecFile); validationErr != nil {
            log.Printf("Validation details: %v", validationErr)
        }
        
        log.Fatalln("Unable to format specification")
    }
    
    log.Println("Specification formatted successfully")
}
```

### Testing and Validation

**Format Testing:**
- Unit tests for specific formatting rules
- Integration tests with sample specifications
- Regression tests for known formatting issues
- Performance tests with large specifications

**Quality Metrics:**
- Schema completeness (all endpoints covered)
- Documentation coverage (descriptions present)
- Type accuracy (correct type assignments)
- Generator compatibility (successful client generation)

## Performance and Optimization

### Processing Efficiency

**Memory Management:**
- Streaming JSON processing for large specifications
- Efficient schema caching and reuse
- Garbage collection optimization for large datasets
- Memory-mapped file access for very large specs

**Processing Speed:**
- Minimal file I/O operations
- Efficient data structure usage
- Parallel processing where applicable
- Caching of expensive operations

### Scalability Considerations

**Large Specification Handling:**
- Incremental processing for very large APIs
- Memory usage optimization
- Progress reporting for long-running operations
- Error recovery and partial processing

**Concurrent Usage:**
- Thread-safe operations
- File locking for concurrent access
- Atomic file operations
- Race condition prevention

## Troubleshooting

### Common Issues

1. **File Not Found**
   - **Cause**: Missing `openapi-spec.json` file
   - **Solution**: Ensure API tests ran successfully and generated the spec file
   - **Prevention**: Add file existence checks in the pipeline

2. **Invalid JSON Format**
   - **Cause**: Corrupted or malformed OpenAPI specification
   - **Solution**: Regenerate specification from API tests
   - **Prevention**: Add JSON validation before formatting

3. **Schema Conflicts**
   - **Cause**: Conflicting type definitions in generated schemas
   - **Solution**: Review API test definitions for consistency
   - **Prevention**: Add schema validation in API tests

4. **Memory Issues**
   - **Cause**: Very large OpenAPI specifications
   - **Solution**: Implement streaming processing or increase memory allocation
   - **Prevention**: Monitor specification size and optimize generation

### Debug Strategies

**Verbose Logging:**
```go
func main() {
    log.SetFlags(log.LstdFlags | log.Lshortfile)
    log.Println("Starting OpenAPI spec formatting...")
    
    if err := opticgo.Format(SpecFile); err != nil {
        log.Printf("Formatting error: %+v", err)
        log.Fatalln("Format operation failed")
    }
    
    log.Println("Formatting completed successfully")
}
```

**Manual Validation:**
```bash
# Validate OpenAPI spec before formatting
openapi-generator-cli validate -i openapi-spec.json

# Check JSON syntax
jq . openapi-spec.json > /dev/null

# Compare before/after formatting
diff -u openapi-spec.json.backup openapi-spec.json
```

## Integration Testing

### Pipeline Validation

**End-to-End Testing:**
1. Run API tests to generate raw specification
2. Apply formatting and validate output
3. Generate client code from formatted specification
4. Compile and test generated client code
5. Verify documentation completeness

**Regression Testing:**
- Compare formatted output against known good specifications
- Validate that formatting doesn't break client generation
- Ensure backward compatibility with existing client code
- Check that all API endpoints remain accessible

### Continuous Integration

**Automated Validation:**
```bash
#!/bin/bash
# Formatting validation script

# 1. Generate raw spec
api generate:oas --json
mv ".optic/generated/openapi.json" "openapi-spec.json"

# 2. Backup original
cp "openapi-spec.json" "openapi-spec.json.backup"

# 3. Apply formatting
go run "spec_format/main.go"

# 4. Validate formatted spec
openapi-generator-cli validate -i "openapi-spec.json"

# 5. Generate client to test compatibility
openapi-generator-cli generate -i "openapi-spec.json" -g go -o "test-client"

# 6. Compile test client
cd test-client && go build ./...

echo "Formatting validation completed successfully"
```

## Best Practices

### Development Guidelines

1. **Minimal Dependencies**: Keep the formatter lightweight and focused
2. **Error Handling**: Provide clear, actionable error messages
3. **Logging**: Include appropriate logging for debugging and monitoring
4. **Performance**: Optimize for speed while maintaining accuracy
5. **Maintainability**: Keep code simple and well-documented

### Operational Practices

1. **Version Control**: Track changes to formatting logic
2. **Testing**: Comprehensive test coverage for formatting rules
3. **Monitoring**: Log formatting operations for pipeline visibility
4. **Backup**: Preserve original specifications before formatting
5. **Documentation**: Maintain clear documentation of formatting rules

### Security Considerations

1. **File Permissions**: Ensure proper file access controls
2. **Input Validation**: Validate input specifications before processing
3. **Error Messages**: Avoid exposing sensitive information in errors
4. **Temporary Files**: Clean up temporary files securely
5. **Resource Limits**: Prevent resource exhaustion attacks

## Future Enhancements

### Planned Improvements

1. **Configuration Support**: External configuration files for formatting rules
2. **Custom Plugins**: Extensible plugin system for custom formatting logic
3. **Format Validation**: Enhanced validation and reporting
4. **Performance Optimization**: Further speed and memory improvements
5. **Documentation Generation**: Enhanced documentation from formatted specs

### Integration Opportunities

1. **IDE Integration**: Real-time formatting in development environments
2. **CI/CD Enhancement**: Better integration with continuous integration pipelines
3. **Monitoring**: Integration with monitoring and alerting systems
4. **Analytics**: Specification quality metrics and reporting
5. **Collaboration**: Multi-developer formatting consistency tools

## Conclusion

The `spec_format/` directory provides essential post-processing for OpenAPI specifications in the WGCF documentation generation pipeline. While simple in implementation, it serves a critical role in ensuring generated specifications meet quality standards and integrate properly with client code generation.

The formatter's focused approach prioritizes reliability and maintainability while providing the necessary standardization for professional API documentation. Its integration with the broader pipeline ensures that the final OpenAPI specifications are optimized for both human consumption and automated client generation.

The tool exemplifies the principle of doing one thing well - it takes raw API specifications and produces clean, standardized output that enhances the entire documentation workflow. This focused approach makes it easy to maintain, debug, and enhance as project requirements evolve.